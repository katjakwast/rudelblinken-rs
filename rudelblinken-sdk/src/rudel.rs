// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * pub-export-macro
//   * disable_custom_section_link_helpers
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod rudel {
    pub mod base {
        /// base is the interface for all basic functionality of the rudelblinken system
        #[allow(dead_code, clippy::all)]
        pub mod base {
            use super::super::super::_rt;
            /// The semantic version of a module
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct SemanticVersion {
                pub major: u8,
                pub minor: u8,
                pub patch: u8,
            }
            impl ::core::fmt::Debug for SemanticVersion {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SemanticVersion")
                        .field("major", &self.major)
                        .field("minor", &self.minor)
                        .field("patch", &self.patch)
                        .finish()
                }
            }
            /// Level of a log entry
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum LogLevel {
                Error,
                Warning,
                Info,
                Debug,
                Trace,
            }
            impl ::core::fmt::Debug for LogLevel {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
                        LogLevel::Warning => f.debug_tuple("LogLevel::Warning").finish(),
                        LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
                        LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
                        LogLevel::Trace => f.debug_tuple("LogLevel::Trace").finish(),
                    }
                }
            }
            impl LogLevel {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> LogLevel {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => LogLevel::Error,
                        1 => LogLevel::Warning,
                        2 => LogLevel::Info,
                        3 => LogLevel::Debug,
                        4 => LogLevel::Trace,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// You need to yield periodically, as the watchdog will kill you if you dont
            pub fn yield_now() {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "yield-now"]
                        fn wit_import();
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        unreachable!()
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sleep for a given amount of time.
            pub fn sleep(micros: u64) {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "sleep"]
                        fn wit_import(_: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i64(&micros));
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the number of microseconds that have passed since boot
            pub fn time() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "time"]
                        fn wit_import() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn has_host_base() -> bool {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "has-host-base"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the rudel base
            ///
            /// If your module requests newer versions of the modules than the host implements, it will attempt to link its old ones anyways and make them conforme to the requested signatures. You can use this function to get the actual version of the host functions.
            ///
            /// If your module requests older versions of the host modules, the host will link compatible functions if available, or abort during linking.
            ///
            /// The host will mock out all functions it can not link.
            pub fn get_base_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-base-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Log a message
            pub fn log(level: LogLevel, message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "log"]
                        fn wit_import(_: i32, _: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(level.clone() as i32, ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// The name of this host. It is guaranteed to be unique, and will not change during the lifetime of the host.
            ///
            /// The name is returned as a list of 16 bytes to avoid the need for allocations on the host side, as the buffer will be allocated by the guest. The name is UTF-8 encoded, and the buffer will be zero padded after the end of the string.
            ///
            /// Once fixed size lists gets stabilized in WIT, this will be changed to a list<u8, 16>. That should not affect the ABI as the representation of a tuple and a fixed size list is the same.
            ///
            /// Your host bindings should provide a wrapper for this that converts the list to a string.
            pub fn get_name() -> (
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
            ) {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-name"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(3).cast::<u8>());
                    let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                    let l6 = i32::from(*ptr0.add(5).cast::<u8>());
                    let l7 = i32::from(*ptr0.add(6).cast::<u8>());
                    let l8 = i32::from(*ptr0.add(7).cast::<u8>());
                    let l9 = i32::from(*ptr0.add(8).cast::<u8>());
                    let l10 = i32::from(*ptr0.add(9).cast::<u8>());
                    let l11 = i32::from(*ptr0.add(10).cast::<u8>());
                    let l12 = i32::from(*ptr0.add(11).cast::<u8>());
                    let l13 = i32::from(*ptr0.add(12).cast::<u8>());
                    let l14 = i32::from(*ptr0.add(13).cast::<u8>());
                    let l15 = i32::from(*ptr0.add(14).cast::<u8>());
                    let l16 = i32::from(*ptr0.add(15).cast::<u8>());
                    (
                        l1 as u8,
                        l2 as u8,
                        l3 as u8,
                        l4 as u8,
                        l5 as u8,
                        l6 as u8,
                        l7 as u8,
                        l8 as u8,
                        l9 as u8,
                        l10 as u8,
                        l11 as u8,
                        l12 as u8,
                        l13 as u8,
                        l14 as u8,
                        l15 as u8,
                        l16 as u8,
                    )
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod rudel {
        pub mod base {
            #[allow(dead_code, clippy::all)]
            pub mod run {
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_run_cabi<T: Guest>() {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::run();
                }
                pub trait Guest {
                    /// Run the program.
                    fn run();
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_rudel_base_run_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name = "rudel:base/run@0.0.1#run"]
                        unsafe extern "C" fn export_run() { $($path_to_types)*::
                        _export_run_cabi::<$ty > () } };
                    };
                }
                #[doc(hidden)]
                pub use __export_rudel_base_run_0_0_1_cabi;
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
    }
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
#[macro_export]
macro_rules! __export_rudel_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::rudel::base::run::__export_rudel_base_run_0_0_1_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::rudel::base::run); const _ : () = {
        #[cfg(target_arch = "wasm32")] #[link_section =
        "component-type:wit-bindgen:0.36.0:rudel:base@0.0.1:rudel:imports and exports"]
        #[doc(hidden)] pub static __WIT_BINDGEN_COMPONENT_TYPE : [u8; 493] = *
        b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xf1\x02\x01A\x02\x01\
A\x04\x01B\x13\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\x01\0\x04\0\x09yield-now\x01\x04\x01@\x01\x06microsw\x01\0\x04\0\x05\
sleep\x01\x05\x01@\0\0w\x04\0\x04time\x01\x06\x01@\0\0\x7f\x04\0\x0dhas-host-bas\
e\x01\x07\x01@\0\0\x01\x04\0\x10get-base-version\x01\x08\x01@\x02\x05level\x03\x07\
messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\0\x0a\x04\0\x08\
get-name\x01\x0b\x03\0\x15rudel:base/base@0.0.1\x05\0\x01B\x02\x01@\0\x01\0\x04\0\
\x03run\x01\0\x04\0\x14rudel:base/run@0.0.1\x05\x01\x04\0\x16rudel:base/rudel@0.\
0.1\x04\0\x0b\x0b\x01\0\x05rudel\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\
\x0dwit-component\x070.220.0\x10wit-bindgen-rust\x060.36.0";
        };
    };
}
#[doc(inline)]
pub use __export_rudel_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:rudel:base@0.0.1:rudel-with-all-of-its-exports-removed:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 516] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xe8\x02\x01A\x02\x01\
A\x02\x01B\x13\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\x01\0\x04\0\x09yield-now\x01\x04\x01@\x01\x06microsw\x01\0\x04\0\x05\
sleep\x01\x05\x01@\0\0w\x04\0\x04time\x01\x06\x01@\0\0\x7f\x04\0\x0dhas-host-bas\
e\x01\x07\x01@\0\0\x01\x04\0\x10get-base-version\x01\x08\x01@\x02\x05level\x03\x07\
messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\0\x0a\x04\0\x08\
get-name\x01\x0b\x03\0\x15rudel:base/base@0.0.1\x05\0\x04\06rudel:base/rudel-wit\
h-all-of-its-exports-removed@0.0.1\x04\0\x0b+\x01\0%rudel-with-all-of-its-export\
s-removed\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.\
220.0\x10wit-bindgen-rust\x060.36.0";
