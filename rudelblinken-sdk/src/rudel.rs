// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * pub-export-macro
//   * disable_custom_section_link_helpers
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod rudel {
    pub mod base {
        /// base is the interface for all basic functionality of the rudelblinken system
        #[allow(dead_code, clippy::all)]
        pub mod base {
            use super::super::super::_rt;
            /// The semantic version of a module
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct SemanticVersion {
                pub major: u8,
                pub minor: u8,
                pub patch: u8,
            }
            impl ::core::fmt::Debug for SemanticVersion {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SemanticVersion")
                        .field("major", &self.major)
                        .field("minor", &self.minor)
                        .field("patch", &self.patch)
                        .finish()
                }
            }
            /// Level of a log entry
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum LogLevel {
                Error,
                Warning,
                Info,
                Debug,
                Trace,
            }
            impl ::core::fmt::Debug for LogLevel {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
                        LogLevel::Warning => f.debug_tuple("LogLevel::Warning").finish(),
                        LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
                        LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
                        LogLevel::Trace => f.debug_tuple("LogLevel::Trace").finish(),
                    }
                }
            }
            impl LogLevel {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> LogLevel {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => LogLevel::Error,
                        1 => LogLevel::Warning,
                        2 => LogLevel::Info,
                        3 => LogLevel::Debug,
                        4 => LogLevel::Trace,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the rudel base
            ///
            /// If your module requests newer versions of the modules than the host implements, it will attempt to link its old ones anyways and make them conforme to the requested signatures. You can use this function to get the actual version of the host functions.
            ///
            /// If your module requests older versions of the host modules, the host will link compatible functions if available, or abort during linking.
            ///
            /// The host will mock out all functions it can not link.
            pub fn get_base_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-base-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// You need to yield periodically, as the watchdog will kill you if you dont
            ///
            /// Will try to sleep for the given duration while still serving callbacks
            ///
            /// Use micros = 0 to sleep for the minimum duration
            ///
            /// Returns the new fuel amount
            pub fn yield_now(micros: u64) -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "yield-now"]
                        fn wit_import(_: i64) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(_rt::as_i64(&micros));
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the remaining fuel
            pub fn get_remaining_fuel() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-remaining-fuel"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sleep for a given amount of time without yielding
            pub fn sleep(micros: u64) {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "sleep"]
                        fn wit_import(_: i64);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i64(&micros));
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the number of microseconds that have passed since boot
            pub fn time() -> u64 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "time"]
                        fn wit_import() -> i64;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Log a message
            pub fn log(level: LogLevel, message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "log"]
                        fn wit_import(_: i32, _: *mut u8, _: usize);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        unreachable!()
                    }
                    wit_import(level.clone() as i32, ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// The name of this host. It is guaranteed to be unique, and will not change during the lifetime of the host.
            ///
            /// The name is returned as a list of 16 bytes to avoid the need for allocations on the host side, as the buffer will be allocated by the guest. The name is UTF-8 encoded, and the buffer will be zero padded after the end of the string.
            ///
            /// Once fixed size lists gets stabilized in WIT, this will be changed to a list<u8, 16>. That should not affect the ABI as the representation of a tuple and a fixed size list is the same.
            ///
            /// Your host bindings should provide a wrapper for this that converts the list to a string.
            pub fn get_name() -> (
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
                u8,
            ) {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 16]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-name"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(3).cast::<u8>());
                    let l5 = i32::from(*ptr0.add(4).cast::<u8>());
                    let l6 = i32::from(*ptr0.add(5).cast::<u8>());
                    let l7 = i32::from(*ptr0.add(6).cast::<u8>());
                    let l8 = i32::from(*ptr0.add(7).cast::<u8>());
                    let l9 = i32::from(*ptr0.add(8).cast::<u8>());
                    let l10 = i32::from(*ptr0.add(9).cast::<u8>());
                    let l11 = i32::from(*ptr0.add(10).cast::<u8>());
                    let l12 = i32::from(*ptr0.add(11).cast::<u8>());
                    let l13 = i32::from(*ptr0.add(12).cast::<u8>());
                    let l14 = i32::from(*ptr0.add(13).cast::<u8>());
                    let l15 = i32::from(*ptr0.add(14).cast::<u8>());
                    let l16 = i32::from(*ptr0.add(15).cast::<u8>());
                    (
                        l1 as u8,
                        l2 as u8,
                        l3 as u8,
                        l4 as u8,
                        l5 as u8,
                        l6 as u8,
                        l7 as u8,
                        l8 as u8,
                        l9 as u8,
                        l10 as u8,
                        l11 as u8,
                        l12 as u8,
                        l13 as u8,
                        l14 as u8,
                        l15 as u8,
                        l16 as u8,
                    )
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the configuration for this guest, as configured over BLE. The
            /// semantics of the configuration depend on the guest.
            pub fn get_config() -> _rt::Vec<u8> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/base@0.0.1")]
                    extern "C" {
                        #[link_name = "get-config"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    _rt::Vec::from_raw_parts(l1.cast(), len3, len3)
                }
            }
        }
        /// Use this interface to control the hardware
        #[allow(dead_code, clippy::all)]
        pub mod hardware {
            use super::super::super::_rt;
            pub type SemanticVersion = super::super::super::rudel::base::base::SemanticVersion;
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct LedColor {
                pub red: u8,
                pub green: u8,
                pub blue: u8,
            }
            impl ::core::fmt::Debug for LedColor {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LedColor")
                        .field("red", &self.red)
                        .field("green", &self.green)
                        .field("blue", &self.blue)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct LedInfo {
                pub color: LedColor,
                pub max_lux: u16,
            }
            impl ::core::fmt::Debug for LedInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LedInfo")
                        .field("color", &self.color)
                        .field("max-lux", &self.max_lux)
                        .finish()
                }
            }
            /// Information about the ambient light sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum AmbientLightType {
                None,
                Basic,
            }
            impl ::core::fmt::Debug for AmbientLightType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AmbientLightType::None => {
                            f.debug_tuple("AmbientLightType::None").finish()
                        }
                        AmbientLightType::Basic => {
                            f.debug_tuple("AmbientLightType::Basic").finish()
                        }
                    }
                }
            }
            impl AmbientLightType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> AmbientLightType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => AmbientLightType::None,
                        1 => AmbientLightType::Basic,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Information about the vibration sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum VibrationSensorType {
                None,
                Ball,
            }
            impl ::core::fmt::Debug for VibrationSensorType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        VibrationSensorType::None => {
                            f.debug_tuple("VibrationSensorType::None").finish()
                        }
                        VibrationSensorType::Ball => {
                            f.debug_tuple("VibrationSensorType::Ball").finish()
                        }
                    }
                }
            }
            impl VibrationSensorType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> VibrationSensorType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => VibrationSensorType::None,
                        1 => VibrationSensorType::Ball,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the hardware interface provided by the runtime.
            ///
            /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
            pub fn get_hardware_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-hardware-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    super::super::super::rudel::base::base::SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Lowlevel function to set the intensities of multiple LEDs
            ///
            /// The values are in lux in the main direction of the LED
            ///
            /// You should probably not use this function directly, but use a higher level abstraction instead
            ///
            /// The first-id is the index of the first LED to set. If the lux list is shorter than the number of LEDs, the remaining LEDs will not be modified. If the lux list is longer than the number of LEDs, the remaining values will be ignored.
            pub fn set_leds(first_id: u16, lux: &[u16]) -> u32 {
                unsafe {
                    let vec0 = lux;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "set-leds"]
                        fn wit_import(_: i32, _: *mut u8, _: usize) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(_rt::as_i32(&first_id), ptr0.cast_mut(), len0);
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Convenience function to set all LEDs
            pub fn set_rgb(color: LedColor, lux: u32) -> u32 {
                unsafe {
                    let LedColor { red: red0, green: green0, blue: blue0 } = color;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "set-rgb"]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i32, _: i32, _: i32) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        _rt::as_i32(red0),
                        _rt::as_i32(green0),
                        _rt::as_i32(blue0),
                        _rt::as_i32(&lux),
                    );
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get information about the number of LEDs
            pub fn led_count() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "led-count"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get information about a specific LED
            ///
            /// If the id does not exist, the function will return a led-info with all values set to 0
            pub fn get_led_info(id: u16) -> LedInfo {
                unsafe {
                    #[repr(align(2))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 6]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 6]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-led-info"]
                        fn wit_import(_: i32, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i32(&id), ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    let l4 = i32::from(*ptr0.add(4).cast::<u16>());
                    LedInfo {
                        color: LedColor {
                            red: l1 as u8,
                            green: l2 as u8,
                            blue: l3 as u8,
                        },
                        max_lux: l4 as u16,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Information about the ambient light sensor.
            ///
            /// This could be extended in the future to indicate more types of sensors in future hardware revisions.
            pub fn get_ambient_light_type() -> AmbientLightType {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-ambient-light-type"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    AmbientLightType::_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get the current ambient light level
            ///
            /// The value is in lux
            pub fn get_ambient_light() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-ambient-light"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Vibration sensor type.
            pub fn get_vibration_sensor_type() -> VibrationSensorType {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-vibration-sensor-type"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    VibrationSensorType::_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get a measure of the vibration level
            ///
            /// TODO: Figure out what this should return
            pub fn get_vibration() -> u32 {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/hardware@0.0.1")]
                    extern "C" {
                        #[link_name = "get-vibration"]
                        fn wit_import() -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u32
                }
            }
        }
        /// Control ble stuff
        #[allow(dead_code, clippy::all)]
        pub mod ble {
            use super::super::super::_rt;
            pub type SemanticVersion = super::super::super::rudel::base::base::SemanticVersion;
            /// Configure the BLE advertisements
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct AdvertisementSettings {
                pub min_interval: u16,
                pub max_interval: u16,
            }
            impl ::core::fmt::Debug for AdvertisementSettings {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AdvertisementSettings")
                        .field("min-interval", &self.min_interval)
                        .field("max-interval", &self.max_interval)
                        .finish()
                }
            }
            /// The data to be sent in the advertisement
            ///
            /// Up to 32 bytes of data
            pub type AdvertisementData = _rt::Vec<u8>;
            #[allow(unused_unsafe, clippy::all)]
            /// Get the version of the hardware interface provided by the runtime.
            ///
            /// The rudelblinken runtime will mock out all functions the it can not link. If this function returns a version that is lower than the version you requested, you should probably not use any of the functions that are not available in that version.
            pub fn get_ble_version() -> SemanticVersion {
                unsafe {
                    #[repr(align(1))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 3]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "get-ble-version"]
                        fn wit_import(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let l2 = i32::from(*ptr0.add(1).cast::<u8>());
                    let l3 = i32::from(*ptr0.add(2).cast::<u8>());
                    super::super::super::rudel::base::base::SemanticVersion {
                        major: l1 as u8,
                        minor: l2 as u8,
                        patch: l3 as u8,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn configure_advertisement(settings: AdvertisementSettings) -> u32 {
                unsafe {
                    let AdvertisementSettings {
                        min_interval: min_interval0,
                        max_interval: max_interval0,
                    } = settings;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "configure-advertisement"]
                        fn wit_import(_: i32, _: i32) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i32) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        _rt::as_i32(min_interval0),
                        _rt::as_i32(max_interval0),
                    );
                    ret as u32
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_advertisement_data(data: &AdvertisementData) -> u32 {
                unsafe {
                    let vec0 = data;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "rudel:base/ble@0.0.1")]
                    extern "C" {
                        #[link_name = "set-advertisement-data"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0);
                    ret as u32
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod rudel {
        pub mod base {
            #[allow(dead_code, clippy::all)]
            pub mod ble_guest {
                use super::super::super::super::_rt;
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Advertisement {
                    pub address: u64,
                    /// Company identifier
                    pub company: u16,
                    /// 32 byte of data
                    /// TODO: Figure out the limit
                    pub data: (u32, u32, u32, u32, u32, u32, u32, u32),
                    /// how many of the data bytes are actually used
                    pub data_length: u8,
                    pub received_at: u64,
                }
                impl ::core::fmt::Debug for Advertisement {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Advertisement")
                            .field("address", &self.address)
                            .field("company", &self.company)
                            .field("data", &self.data)
                            .field("data-length", &self.data_length)
                            .field("received-at", &self.received_at)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_on_advertisement_cabi<T: Guest>(
                    arg0: i64,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i64,
                ) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::on_advertisement(Advertisement {
                        address: arg0 as u64,
                        company: arg1 as u16,
                        data: (
                            arg2 as u32,
                            arg3 as u32,
                            arg4 as u32,
                            arg5 as u32,
                            arg6 as u32,
                            arg7 as u32,
                            arg8 as u32,
                            arg9 as u32,
                        ),
                        data_length: arg10 as u8,
                        received_at: arg11 as u64,
                    });
                }
                pub trait Guest {
                    /// Check if the ble module is implemented
                    ///
                    /// The rudelblinken runtime will mock out all functions the it can not link.
                    /// If this function returns false you should not use any of the other functions
                    fn on_advertisement(advertisement: Advertisement);
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_rudel_base_ble_guest_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "rudel:base/ble-guest@0.0.1#on-advertisement"] unsafe extern "C"
                        fn export_on_advertisement(arg0 : i64, arg1 : i32, arg2 : i32,
                        arg3 : i32, arg4 : i32, arg5 : i32, arg6 : i32, arg7 : i32, arg8
                        : i32, arg9 : i32, arg10 : i32, arg11 : i64,) {
                        $($path_to_types)*:: _export_on_advertisement_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                        arg11) } };
                    };
                }
                #[doc(hidden)]
                pub use __export_rudel_base_ble_guest_0_0_1_cabi;
            }
            #[allow(dead_code, clippy::all)]
            pub mod run {
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_run_cabi<T: Guest>() {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::run();
                }
                pub trait Guest {
                    /// Run the program.
                    fn run();
                }
                #[doc(hidden)]
                #[macro_export]
                macro_rules! __export_rudel_base_run_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name = "rudel:base/run@0.0.1#run"]
                        unsafe extern "C" fn export_run() { $($path_to_types)*::
                        _export_run_cabi::<$ty > () } };
                    };
                }
                #[doc(hidden)]
                pub use __export_rudel_base_run_0_0_1_cabi;
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
#[macro_export]
macro_rules! __export_rudel_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::rudel::base::ble_guest::__export_rudel_base_ble_guest_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::rudel::base::ble_guest);
        $($path_to_types_root)*::
        exports::rudel::base::run::__export_rudel_base_run_0_0_1_cabi!($ty with_types_in
        $($path_to_types_root)*:: exports::rudel::base::run); const _ : () = {
        #[cfg(target_arch = "wasm32")] #[link_section =
        "component-type:wit-bindgen:0.36.0:rudel:base@0.0.1:rudel:imports and exports"]
        #[doc(hidden)] pub static __WIT_BINDGEN_COMPONENT_TYPE : [u8; 1409] = *
        b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x85\x0a\x01A\x02\x01\
A\x0b\x01B\x16\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\0\x01\x04\0\x10get-base-version\x01\x04\x01@\x01\x06microsw\0y\x04\
\0\x09yield-now\x01\x05\x01@\0\0y\x04\0\x12get-remaining-fuel\x01\x06\x01@\x01\x06\
microsw\x01\0\x04\0\x05sleep\x01\x07\x01@\0\0w\x04\0\x04time\x01\x08\x01@\x02\x05\
level\x03\x07messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\
\0\x0a\x04\0\x08get-name\x01\x0b\x01p}\x01@\0\0\x0c\x04\0\x0aget-config\x01\x0d\x03\
\0\x15rudel:base/base@0.0.1\x05\0\x02\x03\0\0\x10semantic-version\x01B\x1b\x02\x03\
\x02\x01\x01\x04\0\x10semantic-version\x03\0\0\x01r\x03\x03red}\x05green}\x04blu\
e}\x04\0\x09led-color\x03\0\x02\x01r\x02\x05color\x03\x07max-lux{\x04\0\x08led-i\
nfo\x03\0\x04\x01m\x02\x04none\x05basic\x04\0\x12ambient-light-type\x03\0\x06\x01\
m\x02\x04none\x04ball\x04\0\x15vibration-sensor-type\x03\0\x08\x01@\0\0\x01\x04\0\
\x14get-hardware-version\x01\x0a\x01p{\x01@\x02\x08first-id{\x03lux\x0b\0y\x04\0\
\x08set-leds\x01\x0c\x01@\x02\x05color\x03\x03luxy\0y\x04\0\x07set-rgb\x01\x0d\x01\
@\0\0y\x04\0\x09led-count\x01\x0e\x01@\x01\x02id{\0\x05\x04\0\x0cget-led-info\x01\
\x0f\x01@\0\0\x07\x04\0\x16get-ambient-light-type\x01\x10\x04\0\x11get-ambient-l\
ight\x01\x0e\x01@\0\0\x09\x04\0\x19get-vibration-sensor-type\x01\x11\x04\0\x0dge\
t-vibration\x01\x0e\x03\0\x19rudel:base/hardware@0.0.1\x05\x02\x01B\x0c\x02\x03\x02\
\x01\x01\x04\0\x10semantic-version\x03\0\0\x01r\x02\x0cmin-interval{\x0cmax-inte\
rval{\x04\0\x16advertisement-settings\x03\0\x02\x01p}\x04\0\x12advertisement-dat\
a\x03\0\x04\x01@\0\0\x01\x04\0\x0fget-ble-version\x01\x06\x01@\x01\x08settings\x03\
\0y\x04\0\x17configure-advertisement\x01\x07\x01@\x01\x04data\x05\0y\x04\0\x16se\
t-advertisement-data\x01\x08\x03\0\x14rudel:base/ble@0.0.1\x05\x03\x01B\x05\x01o\
\x08yyyyyyyy\x01r\x05\x07addressw\x07company{\x04data\0\x0bdata-length}\x0brecei\
ved-atw\x04\0\x0dadvertisement\x03\0\x01\x01@\x01\x0dadvertisement\x02\x01\0\x04\
\0\x10on-advertisement\x01\x03\x04\0\x1arudel:base/ble-guest@0.0.1\x05\x04\x01B\x02\
\x01@\0\x01\0\x04\0\x03run\x01\0\x04\0\x14rudel:base/run@0.0.1\x05\x05\x04\0\x16\
rudel:base/rudel@0.0.1\x04\0\x0b\x0b\x01\0\x05rudel\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.220.0\x10wit-bindgen-rust\x060.36.0";
        };
    };
}
#[doc(inline)]
pub use __export_rudel_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:rudel:base@0.0.1:rudel-with-all-of-its-exports-removed:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1274] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xde\x08\x01A\x02\x01\
A\x07\x01B\x16\x01r\x03\x05major}\x05minor}\x05patch}\x04\0\x10semantic-version\x03\
\0\0\x01m\x05\x05error\x07warning\x04info\x05debug\x05trace\x04\0\x09log-level\x03\
\0\x02\x01@\0\0\x01\x04\0\x10get-base-version\x01\x04\x01@\x01\x06microsw\0y\x04\
\0\x09yield-now\x01\x05\x01@\0\0y\x04\0\x12get-remaining-fuel\x01\x06\x01@\x01\x06\
microsw\x01\0\x04\0\x05sleep\x01\x07\x01@\0\0w\x04\0\x04time\x01\x08\x01@\x02\x05\
level\x03\x07messages\x01\0\x04\0\x03log\x01\x09\x01o\x10}}}}}}}}}}}}}}}}\x01@\0\
\0\x0a\x04\0\x08get-name\x01\x0b\x01p}\x01@\0\0\x0c\x04\0\x0aget-config\x01\x0d\x03\
\0\x15rudel:base/base@0.0.1\x05\0\x02\x03\0\0\x10semantic-version\x01B\x1b\x02\x03\
\x02\x01\x01\x04\0\x10semantic-version\x03\0\0\x01r\x03\x03red}\x05green}\x04blu\
e}\x04\0\x09led-color\x03\0\x02\x01r\x02\x05color\x03\x07max-lux{\x04\0\x08led-i\
nfo\x03\0\x04\x01m\x02\x04none\x05basic\x04\0\x12ambient-light-type\x03\0\x06\x01\
m\x02\x04none\x04ball\x04\0\x15vibration-sensor-type\x03\0\x08\x01@\0\0\x01\x04\0\
\x14get-hardware-version\x01\x0a\x01p{\x01@\x02\x08first-id{\x03lux\x0b\0y\x04\0\
\x08set-leds\x01\x0c\x01@\x02\x05color\x03\x03luxy\0y\x04\0\x07set-rgb\x01\x0d\x01\
@\0\0y\x04\0\x09led-count\x01\x0e\x01@\x01\x02id{\0\x05\x04\0\x0cget-led-info\x01\
\x0f\x01@\0\0\x07\x04\0\x16get-ambient-light-type\x01\x10\x04\0\x11get-ambient-l\
ight\x01\x0e\x01@\0\0\x09\x04\0\x19get-vibration-sensor-type\x01\x11\x04\0\x0dge\
t-vibration\x01\x0e\x03\0\x19rudel:base/hardware@0.0.1\x05\x02\x01B\x0c\x02\x03\x02\
\x01\x01\x04\0\x10semantic-version\x03\0\0\x01r\x02\x0cmin-interval{\x0cmax-inte\
rval{\x04\0\x16advertisement-settings\x03\0\x02\x01p}\x04\0\x12advertisement-dat\
a\x03\0\x04\x01@\0\0\x01\x04\0\x0fget-ble-version\x01\x06\x01@\x01\x08settings\x03\
\0y\x04\0\x17configure-advertisement\x01\x07\x01@\x01\x04data\x05\0y\x04\0\x16se\
t-advertisement-data\x01\x08\x03\0\x14rudel:base/ble@0.0.1\x05\x03\x04\06rudel:b\
ase/rudel-with-all-of-its-exports-removed@0.0.1\x04\0\x0b+\x01\0%rudel-with-all-\
of-its-exports-removed\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-co\
mponent\x070.220.0\x10wit-bindgen-rust\x060.36.0";
